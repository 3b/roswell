#!/bin/sh
#|-*- mode:lisp -*-|#
#|List Information
exec ros +Q -m roswell -L sbcl-bin -- $0 "$@"
|#

(when (cl:find-package :ros.sub.list)
  (push :ros.sub.list *features*))

#-ros.util
(load (make-pathname
       :defaults *load-pathname*
       :name "util" :type "lisp"))

#-ros.sub.list
(defpackage :ros.sub.list
  (:use :cl :ros.util))

(in-package :ros.sub.list)

#-ros.sub.list
(defun list-impls (impl &key function params)
  (declare (ignorable params))
  (let ((dir (directory
              (make-pathname
               :defaults (merge-pathnames
                          (format nil "impls/~A/~A/~A/" (uname-m) (uname) impl)
                          (homedir))
               :name :wild
               :type :wild))))
    (mapcar function
            dir)))

#-ros.sub.list
(progn
  (export
   (defun installed (&rest r)
     (cond
       ((null r)
        (format *error-output* "Installed implementations:~%")
        (finish-output *error-output*)
        (let ((dir (directory
                    (make-pathname
                     :defaults (merge-pathnames
                                (format nil "impls/~A/~A/" (uname-m) (uname))
                                (homedir))
                     :name :wild
                     :type :wild))))
          (mapc (lambda (d) (format t "~A~%" (first (last (pathname-directory d)))))  dir))
        (finish-output *standard-output*)
        (format *error-output* "~%For further details on each implementation: ros list installed [implementation]~2%"))
       ((probe-file
         (merge-pathnames
          (format nil "impls/~A/~A/~A" (uname-m) (uname) (first r))
          (homedir)))
        (list-impls (first r)
                    :function (lambda (d) (format t "~A/~A~%"
                                                  (first r)
                                                  (first (last (pathname-directory d)))))
                    :params r)))))
  (export
   (defun dump (&rest params)
     (format *error-output* "List of dumped images for ~A:~%" (impl (first params)))
     (format t "~{~A~%~}"
             (mapcar #'pathname-name
                     (directory (make-pathname :name :wild
                                               :type "core"
                                               :defaults
                                               (merge-pathnames (format nil "impls/~A/~A/~A/dump/"
                                                                        (uname-m) (uname) (impl (first params)))
                                                                (homedir))))))))
  (export
   (defun versions (&rest params)
     (format *error-output* "installable version for impl ~A:~%" (first params))
     (let ((path (and (first params)
                      (or (probe-file (make-pathname
                                       :defaults *load-pathname*
                                       :type "lisp"
                                       :name (format nil "install-~A" (first params))))
                          (probe-file (make-pathname
                                       :defaults *load-pathname*
                                       :type "lisp"
                                       :name (format nil "install+~A" (first params))))))))
       (when path
         (ros:script nil (make-pathname :defaults *load-pathname* :name "install" :type "lisp"))
         (load path)
         (let ((cmd (read-from-string "ros.install::*list-cmd*")))
           (and (boundp cmd)
                (symbol-value cmd)
                (setq cmd (cdr (assoc (first params) (symbol-value cmd) :test 'equal)))
                (dolist (v (funcall cmd))
                  (format t "~A~%" v)))))))))

#-ros.sub.list
(defun main (subcmd cmd &rest r)
  (declare (ignorable cmd))
  (let* ((*read-eval*)
         (symbol (read-from-string (first r)))
         (f (ignore-errors (fdefinition symbol))))
    (if (and f (eql :external (nth-value 1 (find-symbol (string symbol)))))
        (apply f (rest r))
        (format *error-output* "not suppported type for list~%"))))
